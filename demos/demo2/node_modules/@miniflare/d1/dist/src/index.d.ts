import type { fetch } from '@miniflare/core';
import { Plugin } from '@miniflare/shared';
import { PluginContext } from '@miniflare/shared';
import { RequestInfo } from '@miniflare/core';
import { RequestInit } from '@miniflare/core';
import { Response } from '@miniflare/core';
import { SetupResult } from '@miniflare/shared';
import type { SqliteDB } from '@miniflare/shared';
import { StorageFactory } from '@miniflare/shared';

export declare class D1Database {
    private readonly binding;
    constructor(binding: DatabaseBinding);
    prepare(query: string): D1PreparedStatement;
    dump(): Promise<ArrayBuffer>;
    batch<T = unknown>(statements: D1PreparedStatement[]): Promise<D1Result<T>[]>;
    exec<T = unknown>(query: string): Promise<D1ExecResult>;
    _send<T = unknown>(endpoint: string, query: any, params: any[], dothrow?: boolean): Promise<D1Result<T>[] | D1Result<T>>;
}

export declare class D1DatabaseAPI {
    #private;
    private readonly db;
    constructor(db: SqliteDB);
    fetch(input: RequestInfo, init?: RequestInit): Promise<Response<unknown[]>>;
}

export declare type D1ExecResult = {
    count: number;
    duration: number;
};

export declare interface D1Options {
    d1Databases?: string[];
    d1Persist?: boolean | string;
}

export declare class D1Plugin extends Plugin<D1Options> implements D1Options {
    #private;
    d1Databases?: string[];
    d1Persist?: boolean | string;
    constructor(ctx: PluginContext, options?: D1Options);
    getDatabase(storageFactory: StorageFactory, dbName: string): Promise<D1Database>;
    setup(storageFactory: StorageFactory): Promise<SetupResult>;
}

export declare class D1PreparedStatement {
    readonly statement: string;
    private readonly database;
    params: any[];
    constructor(database: D1Database, statement: string, values?: any);
    bind(...values: any[]): D1PreparedStatement;
    first<T = unknown>(colName?: string): Promise<T | null>;
    run<T = unknown>(): Promise<D1Result<T>>;
    all<T = unknown>(): Promise<D1Result<T>>;
    raw<T = unknown>(): Promise<T[]>;
}

export declare type D1Result<T = unknown> = {
    results?: T[];
    success: boolean;
    error?: string;
    meta: any;
};

export declare type DatabaseBinding = {
    fetch: typeof fetch;
};

export { }
