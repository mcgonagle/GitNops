var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// packages/d1/src/index.ts
__export(exports, {
  D1Database: () => D1Database,
  D1DatabaseAPI: () => D1DatabaseAPI,
  D1Plugin: () => D1Plugin,
  D1PreparedStatement: () => D1PreparedStatement
});

// packages/d1/src/api.ts
var import_crypto = __toModule(require("crypto"));
var import_promises = __toModule(require("fs/promises"));
var import_os = __toModule(require("os"));
var import_path = __toModule(require("path"));
var import_perf_hooks = __toModule(require("perf_hooks"));
var import_core = __toModule(require("@miniflare/core"));

// packages/d1/src/splitter.ts
function mayContainMultipleStatements(sql) {
  const trimmed = sql.trimEnd();
  const semiColonIndex = trimmed.indexOf(";");
  return semiColonIndex !== -1 && semiColonIndex !== trimmed.length - 1;
}
function splitSqlQuery(sql) {
  if (!mayContainMultipleStatements(sql))
    return [sql];
  const split = splitSqlIntoStatements(sql);
  if (split.length === 0) {
    return [sql];
  } else {
    return split;
  }
}
function splitSqlIntoStatements(sql) {
  const statements = [];
  let str = "";
  const compoundStatementStack = [];
  const iterator = sql[Symbol.iterator]();
  let next = iterator.next();
  while (!next.done) {
    const char = next.value;
    if (compoundStatementStack[0]?.(str + char)) {
      compoundStatementStack.shift();
    }
    switch (char) {
      case `'`:
      case `"`:
      case "`":
        str += char + consumeUntilMarker(iterator, char);
        break;
      case `$`: {
        const dollarQuote = "$" + consumeWhile(iterator, isDollarQuoteIdentifier);
        str += dollarQuote;
        if (dollarQuote.endsWith("$")) {
          str += consumeUntilMarker(iterator, dollarQuote);
        }
        break;
      }
      case `-`:
        str += char;
        next = iterator.next();
        if (!next.done && next.value === "-") {
          str += next.value + consumeUntilMarker(iterator, "\n");
          break;
        } else {
          continue;
        }
      case `/`:
        str += char;
        next = iterator.next();
        if (!next.done && next.value === "*") {
          str += next.value + consumeUntilMarker(iterator, "*/");
          break;
        } else {
          continue;
        }
      case `;`:
        if (compoundStatementStack.length === 0) {
          statements.push(str);
          str = "";
        } else {
          str += char;
        }
        break;
      default:
        str += char;
        break;
    }
    if (isCompoundStatementStart(str)) {
      compoundStatementStack.unshift(isCompoundStatementEnd);
    }
    next = iterator.next();
  }
  statements.push(str);
  return statements.map((statement) => statement.trim()).filter((statement) => statement.length > 0);
}
function consumeWhile(iterator, predicate) {
  let next = iterator.next();
  let str = "";
  while (!next.done) {
    str += next.value;
    if (!predicate(str)) {
      break;
    }
    next = iterator.next();
  }
  return str;
}
function consumeUntilMarker(iterator, endMarker) {
  return consumeWhile(iterator, (str) => !str.endsWith(endMarker));
}
function isDollarQuoteIdentifier(str) {
  const lastChar = str.slice(-1);
  return lastChar !== "$" && (/[0-9_]/i.test(lastChar) || lastChar.toLowerCase() !== lastChar.toUpperCase());
}
function isCompoundStatementStart(str) {
  return /\sBEGIN\s$/.test(str);
}
function isCompoundStatementEnd(str) {
  return /\sEND[;\s]$/.test(str);
}

// packages/d1/src/api.ts
var served_by = "miniflare.db";
function ok(results, meta) {
  const duration = import_perf_hooks.performance.now() - meta.start;
  return {
    results,
    duration,
    success: true,
    served_by,
    meta: {
      duration,
      last_row_id: meta.last_row_id ?? 0,
      changes: meta.changes ?? 0,
      served_by,
      internal_stats: null
    },
    lastRowId: null,
    changes: null
  };
}
function err(error) {
  return {
    error: String(error),
    success: false,
    served_by
  };
}
function normaliseParams(params) {
  return (params ?? []).map((param) => Array.isArray(param) ? new Uint8Array(param) : param);
}
function normaliseResults(rows) {
  return rows.map((row) => Object.fromEntries(Object.entries(row).map(([key, value]) => [
    key,
    value instanceof Buffer ? Array.from(value) : value
  ])));
}
var EXECUTE_RETURNS_DATA_MESSAGE = "SQL execute error: Execute returned results - did you mean to call query?";
var D1DatabaseAPI = class {
  constructor(db) {
    this.db = db;
  }
  #prepareAndBind(query) {
    const sql = splitSqlQuery(query.sql)[0];
    const stmt = this.db.prepare(sql);
    const params = normaliseParams(query.params);
    if (params.length === 0)
      return stmt;
    try {
      return stmt.bind(params);
    } catch (e) {
      try {
        return stmt.bind(Object.fromEntries(params.map((v, i) => [i + 1, v])));
      } catch {
      }
      throw e;
    }
  }
  #query = (query) => {
    const meta = { start: import_perf_hooks.performance.now() };
    const stmt = this.#prepareAndBind(query);
    let results;
    if (stmt.reader) {
      results = stmt.all();
    } else {
      const result = stmt.run();
      results = [];
      meta.last_row_id = Number(result.lastInsertRowid);
      meta.changes = result.changes;
    }
    return ok(normaliseResults(results), meta);
  };
  #execute = (query) => {
    const meta = { start: import_perf_hooks.performance.now() };
    const stmt = this.#prepareAndBind(query);
    if (stmt.reader)
      throw new Error(EXECUTE_RETURNS_DATA_MESSAGE);
    const result = stmt.run();
    meta.last_row_id = Number(result.lastInsertRowid);
    meta.changes = result.changes;
    return ok(null, meta);
  };
  async #handleQueryExecute(request, runner) {
    const query = await request.json();
    let results;
    if (Array.isArray(query)) {
      const savepointName = `MINIFLARE_D1_BATCH_${Date.now()}_${Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)}`;
      this.db.exec(`SAVEPOINT ${savepointName};`);
      try {
        results = query.map(runner);
        this.db.exec(`RELEASE ${savepointName};`);
      } catch (e) {
        this.db.exec(`ROLLBACK TO ${savepointName};`);
        this.db.exec(`RELEASE ${savepointName};`);
        throw e;
      }
    } else {
      results = runner(query);
    }
    return import_core.Response.json(results);
  }
  async #handleDump() {
    const random = import_crypto.default.randomBytes(8).toString("hex");
    const tmpPath = import_path.default.join(import_os.default.tmpdir(), `miniflare-d1-dump-${random}.db`);
    await this.db.backup(tmpPath);
    const buffer = await import_promises.default.readFile(tmpPath);
    void import_promises.default.unlink(tmpPath).catch(() => {
    });
    return new import_core.Response(buffer, {
      headers: { "Content-Type": "application/octet-stream" }
    });
  }
  async fetch(input, init) {
    if (typeof input === "string")
      input = new URL(input, "http://localhost");
    const request = new import_core.Request(input, init);
    if (!(input instanceof URL))
      input = new URL(request.url);
    const pathname = input.pathname;
    if (request.method !== "POST")
      return new import_core.Response(null, { status: 405 });
    try {
      if (pathname === "/query") {
        return await this.#handleQueryExecute(request, this.#query);
      } else if (pathname === "/execute") {
        return await this.#handleQueryExecute(request, this.#execute);
      } else if (pathname === "/dump") {
        return await this.#handleDump();
      }
    } catch (e) {
      return import_core.Response.json(err(e));
    }
    return new import_core.Response(null, { status: 404 });
  }
};

// packages/d1/src/d1js.ts
var D1Database = class {
  binding;
  constructor(binding) {
    this.binding = binding;
  }
  prepare(query) {
    return new D1PreparedStatement(this, query);
  }
  async dump() {
    const response = await this.binding.fetch("/dump", {
      method: "POST",
      headers: {
        "content-type": "application/json"
      }
    });
    if (response.status !== 200) {
      try {
        const err2 = await response.json();
        throw new Error("D1_DUMP_ERROR", {
          cause: new Error(err2.error)
        });
      } catch (e) {
        throw new Error("D1_DUMP_ERROR", {
          cause: new Error("Status " + response.status)
        });
      }
    }
    return await response.arrayBuffer();
  }
  async batch(statements) {
    const exec = await this._send("/query", statements.map((s) => s.statement), statements.map((s) => s.params));
    return exec;
  }
  async exec(query) {
    const lines = query.trim().split("\n");
    const _exec = await this._send("/query", lines, [], false);
    const exec = Array.isArray(_exec) ? _exec : [_exec];
    const error = exec.map((r) => {
      return r.error ? 1 : 0;
    }).indexOf(1);
    if (error !== -1) {
      throw new Error("D1_EXEC_ERROR", {
        cause: new Error("Error in line " + (error + 1) + ": " + lines[error] + ": " + exec[error].error)
      });
    } else {
      return {
        count: exec.length,
        duration: exec.reduce((p, c) => {
          return p + c.meta.duration;
        }, 0)
      };
    }
  }
  async _send(endpoint, query, params, dothrow = true) {
    const body = JSON.stringify(typeof query == "object" ? query.map((s, index) => {
      return { sql: s, params: params[index] };
    }) : {
      sql: query,
      params
    });
    const response = await this.binding.fetch(endpoint, {
      method: "POST",
      headers: {
        "content-type": "application/json"
      },
      body
    });
    try {
      const answer = await response.json();
      if (answer.error && dothrow) {
        const err2 = answer;
        throw new Error("D1_ERROR", { cause: new Error(err2.error) });
      } else {
        return Array.isArray(answer) ? answer.map((r) => mapD1Result(r)) : mapD1Result(answer);
      }
    } catch (e) {
      throw new Error("D1_ERROR", {
        cause: new Error(e.cause || "Something went wrong")
      });
    }
  }
};
var D1PreparedStatement = class {
  statement;
  database;
  params;
  constructor(database, statement, values) {
    this.database = database;
    this.statement = statement;
    this.params = values || [];
  }
  bind(...values) {
    for (var r in values) {
      switch (typeof values[r]) {
        case "number":
        case "string":
          break;
        case "object":
          if (values[r] == null)
            break;
          if (Array.isArray(values[r]) && values[r].map((b) => {
            return typeof b == "number" && b >= 0 && b < 256 ? 1 : 0;
          }).indexOf(0) == -1)
            break;
          if (values[r] instanceof ArrayBuffer) {
            values[r] = Array.from(new Uint8Array(values[r]));
            break;
          }
          if (ArrayBuffer.isView(values[r])) {
            values[r] = Array.from(values[r]);
            break;
          }
        default:
          throw new Error("D1_TYPE_ERROR", {
            cause: new Error("Type '" + typeof values[r] + "' not supported for value '" + values[r] + "'")
          });
      }
    }
    return new D1PreparedStatement(this.database, this.statement, values);
  }
  async first(colName) {
    const info = firstIfArray(await this.database._send("/query", this.statement, this.params));
    const results = info.results ?? [];
    if (colName !== void 0) {
      if (results.length > 0 && results[0][colName] === void 0) {
        throw new Error("D1_COLUMN_NOTFOUND", {
          cause: new Error("Column not found")
        });
      }
      return results.length < 1 ? null : results[0][colName];
    } else {
      return results.length < 1 ? null : results[0];
    }
  }
  async run() {
    return firstIfArray(await this.database._send("/execute", this.statement, this.params));
  }
  async all() {
    return firstIfArray(await this.database._send("/query", this.statement, this.params));
  }
  async raw() {
    const s = firstIfArray(await this.database._send("/query", this.statement, this.params));
    const raw = [];
    for (const r in s.results) {
      const entry = Object.keys(s.results[r]).map((k) => {
        return s.results[r][k];
      });
      raw.push(entry);
    }
    return raw;
  }
};
function firstIfArray(results) {
  return Array.isArray(results) ? results[0] : results;
}
function mapD1Result(result) {
  let map = {
    results: result.results || [],
    success: result.success === void 0 ? true : result.success,
    meta: result.meta || {}
  };
  result.error && (map.error = result.error);
  return map;
}

// packages/d1/src/plugin.ts
var import_shared = __toModule(require("@miniflare/shared"));
var D1_BETA_PREFIX = `__D1_BETA__`;
var D1Plugin = class extends import_shared.Plugin {
  d1Databases;
  d1Persist;
  #persist;
  constructor(ctx, options) {
    super(ctx);
    this.assignOptions(options);
    this.#persist = (0, import_shared.resolveStoragePersist)(ctx.rootPath, this.d1Persist);
  }
  async getDatabase(storageFactory, dbName) {
    const storage = await storageFactory.storage(dbName, this.#persist);
    const db = await storage.getSqliteDatabase();
    return new D1Database(new D1DatabaseAPI(db));
  }
  async setup(storageFactory) {
    const bindings = {};
    for (const dbName of this.d1Databases ?? []) {
      if (dbName.startsWith(D1_BETA_PREFIX)) {
        bindings[dbName] = await this.getDatabase(storageFactory, dbName.slice(D1_BETA_PREFIX.length));
      } else {
        console.warn(`Not injecting D1 Database for '${dbName}' as this version of Miniflare only supports D1 beta bindings. Upgrade Wrangler and/or Miniflare and try again.`);
      }
    }
    return { bindings };
  }
};
__decorateClass([
  (0, import_shared.Option)({
    type: import_shared.OptionType.ARRAY,
    name: "d1",
    description: "D1 namespace to bind",
    logName: "D1 Namespaces",
    fromWrangler: ({ d1_databases }) => d1_databases?.map(({ binding }) => binding)
  })
], D1Plugin.prototype, "d1Databases", 2);
__decorateClass([
  (0, import_shared.Option)({
    type: import_shared.OptionType.BOOLEAN_STRING,
    description: "Persist D1 data (to optional path)",
    logName: "D1 Persistence",
    fromWrangler: ({ miniflare }) => miniflare?.d1_persist
  })
], D1Plugin.prototype, "d1Persist", 2);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  D1Database,
  D1DatabaseAPI,
  D1Plugin,
  D1PreparedStatement
});
//# sourceMappingURL=index.js.map
