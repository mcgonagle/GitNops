/// <reference types="node" />

import { Blob as Blob_2 } from 'buffer';
import { Headers } from 'undici';
import { ParsedRange } from '@miniflare/shared';
import { Plugin } from '@miniflare/shared';
import { PluginContext } from '@miniflare/shared';
import { ReadableStream } from 'stream/web';
import { SetupResult } from '@miniflare/shared';
import { Storage } from '@miniflare/shared';
import { StorageFactory } from '@miniflare/shared';

export declare class Checksums implements R2Checksums<ArrayBuffer> {
    #private;
    constructor(checksums: R2Checksums<string>);
    get md5(): ArrayBuffer | undefined;
    get sha1(): ArrayBuffer | undefined;
    get sha256(): ArrayBuffer | undefined;
    get sha384(): ArrayBuffer | undefined;
    get sha512(): ArrayBuffer | undefined;
    toJSON(): R2Checksums<string>;
}

export declare function createMD5Hash(input: Uint8Array): string;

export declare function createMultipartUpload(key: string, metadata: R2MultipartIndexMetadata, opts: InternalR2MultipartUploadOptions): Promise<R2MultipartUpload>;

export declare function createVersion(): string;

export declare function deleteMultipartParts(storage: Storage, key: string, uploadId: string, excludeKeys?: Set<string>): Promise<void>;

export declare function getMultipartValue(storage: Storage, key: string, multipart: R2MultipartReference, range: ParsedRange): ReadableStream<Uint8Array>;

export declare const HEX_REGEXP: RegExp;

/* Excluded from this release type: _INTERNAL_PREFIX */

export declare interface InternalR2BucketOptions {
    blockGlobalAsyncIO?: boolean;
    listRespectInclude?: boolean;
    minMultipartUploadSize?: number;
}

export declare interface InternalR2MultipartUploadOptions {
    storage: Storage;
    blockGlobalAsyncIO?: boolean;
    minMultipartUploadSize?: number;
}

export declare const MAX_KEY_SIZE = 1024;

export declare function parseHttpMetadata(httpMetadata?: R2HTTPMetadata | Headers): R2HTTPMetadata;

export declare function parseOnlyIf(onlyIf?: R2ConditionalUnparsed | R2Conditional | Headers): R2Conditional;

export declare function parseR2ObjectMetadata(meta: R2ObjectMetadata): void;

export declare const R2_HASH_ALGORITHMS: readonly [{
    readonly name: "MD5";
    readonly field: "md5";
    readonly expectedBytes: 16;
}, {
    readonly name: "SHA-1";
    readonly field: "sha1";
    readonly expectedBytes: 20;
}, {
    readonly name: "SHA-256";
    readonly field: "sha256";
    readonly expectedBytes: 32;
}, {
    readonly name: "SHA-384";
    readonly field: "sha384";
    readonly expectedBytes: 48;
}, {
    readonly name: "SHA-512";
    readonly field: "sha512";
    readonly expectedBytes: 64;
}];

export declare class R2Bucket {
    #private;
    constructor(storage: Storage, { blockGlobalAsyncIO, listRespectInclude, minMultipartUploadSize, }?: InternalR2BucketOptions);
    head(key: string): Promise<R2Object | null>;
    /**
     * Returns R2Object on a failure of the conditional specified in onlyIf.
     */
    get(key: string): Promise<R2ObjectBody | null>;
    get(key: string, options: R2GetOptions): Promise<R2ObjectBody | R2Object | null>;
    put(key: string, value: R2PutValueType, options?: R2PutOptions): Promise<R2Object | null>;
    delete(keys: string | string[]): Promise<void>;
    list(listOptions?: R2ListOptions): Promise<R2Objects>;
    createMultipartUpload(key: string, options?: R2MultipartOptions): Promise<R2MultipartUpload>;
    resumeMultipartUpload(key: string, uploadId: string): R2MultipartUpload;
}

export declare interface R2Checksums<T extends ArrayBuffer | string> {
    md5?: T;
    sha1?: T;
    sha256?: T;
    sha384?: T;
    sha512?: T;
}

export declare interface R2Conditional {
    etagMatches?: string | string[];
    etagDoesNotMatch?: string | string[];
    uploadedBefore?: Date;
    uploadedAfter?: Date;
}

export declare interface R2ConditionalUnparsed {
    etagMatches?: string | string[];
    etagDoesNotMatch?: string | string[];
    uploadedBefore?: string | Date;
    uploadedAfter?: string | Date;
}

export declare interface R2GetOptions {
    onlyIf?: R2Conditional | Headers;
    range?: R2Range | Headers;
}

export declare type R2HashAlgorithm = typeof R2_HASH_ALGORITHMS[number];

/**
 * Metadata that's automatically rendered into R2 HTTP API endpoints.
 * ```
 * * contentType -> content-type
 * * contentLanguage -> content-language
 * etc...
 * ```
 * This data is echoed back on GET responses based on what was originally
 * assigned to the object (and can typically also be overriden when issuing
 * the GET request).
 */
export declare interface R2HTTPMetadata {
    contentType?: string;
    contentLanguage?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    cacheControl?: string;
    cacheExpiry?: Date;
}

export declare interface R2ListOptions {
    limit?: number;
    prefix?: string;
    cursor?: string;
    startAfter?: string;
    delimiter?: string;
    include?: R2ListOptionsInclude;
}

export declare type R2ListOptionsInclude = ("httpMetadata" | "customMetadata")[];

export declare type R2MultipartIndexMetadata = R2MultipartPendingIndexMetadata | {
    aborted: true;
} | {
    completed: true;
};

export declare type R2MultipartOptions = Pick<R2PutOptions, "httpMetadata" | "customMetadata">;

export declare interface R2MultipartPendingIndexMetadata {
    httpMetadata: R2ObjectMetadata["httpMetadata"];
    customMetadata: R2ObjectMetadata["customMetadata"];
}

export declare interface R2MultipartReference {
    uploadId: string;
    parts: {
        partNumber: number;
        size: number;
    }[];
}

export declare class R2MultipartUpload {
    #private;
    readonly key: string;
    readonly uploadId: string;
    constructor(key: string, uploadId: string, opts: InternalR2MultipartUploadOptions);
    uploadPart(partNumber: number, value: ReadableStream | ArrayBuffer | ArrayBufferView | string | Blob_2): Promise<R2UploadedPart>;
    abort(): Promise<void>;
    complete(uploadedParts: R2UploadedPart[]): Promise<R2Object>;
}

/**
 * R2Object is created when you PUT an object into an R2 bucket.
 * R2Object represents the metadata of an object based on the information
 * provided by the uploader. Every object that you PUT into an R2 bucket
 * will have an R2Object created.
 */
export declare class R2Object {
    #private;
    readonly key: string;
    readonly version: string;
    readonly size: number;
    readonly etag: string;
    readonly httpEtag: string;
    readonly uploaded: Date;
    readonly httpMetadata: R2HTTPMetadata;
    readonly customMetadata: Record<string, string>;
    readonly range?: R2Range;
    constructor(metadata: R2ObjectMetadata);
    get checksums(): Checksums;
    writeHttpMetadata(headers: Headers): void;
}

export declare class R2ObjectBody extends R2Object {
    readonly body: ReadableStream<Uint8Array>;
    constructor(metadata: R2ObjectMetadata, value: Uint8Array | ReadableStream<Uint8Array>);
    get bodyUsed(): boolean;
    arrayBuffer(): Promise<ArrayBuffer>;
    text(): Promise<string>;
    json<T>(): Promise<T>;
    blob(): Promise<Blob_2>;
}

export declare interface R2ObjectMetadata {
    key: string;
    version: string;
    size: number;
    etag: string;
    httpEtag: string;
    uploaded: Date;
    httpMetadata: R2HTTPMetadata;
    customMetadata: Record<string, string>;
    range?: R2Range;
    checksums?: R2Checksums<string>;
    multipart?: R2MultipartReference;
}

export declare interface R2Objects {
    objects: R2Object[];
    truncated: boolean;
    cursor?: string;
    delimitedPrefixes: string[];
}

export declare interface R2Options {
    r2Buckets?: string[];
    r2Persist?: boolean | string;
}

export declare class R2Plugin extends Plugin<R2Options> implements R2Options {
    #private;
    r2Buckets?: string[];
    r2Persist?: boolean | string;
    constructor(ctx: PluginContext, options?: R2Options);
    getBucket(storage: StorageFactory, bucket: string, blockGlobalAsyncIO?: boolean): R2Bucket;
    setup(storageFactory: StorageFactory): SetupResult;
}

export declare interface R2PutOptions extends R2Checksums<ArrayBuffer | string> {
    onlyIf?: R2Conditional | Headers;
    httpMetadata?: R2HTTPMetadata | Headers;
    customMetadata?: Record<string, string>;
}

export declare type R2PutValueType = ReadableStream | ArrayBuffer | ArrayBufferView | string | null | Blob_2;

export declare interface R2Range {
    offset?: number;
    length?: number;
    suffix?: number;
}

export declare interface R2UploadedPart {
    partNumber: number;
    etag: string;
}

export declare function testR2Conditional(conditional: R2Conditional, metadata?: Pick<R2ObjectMetadata, "etag" | "uploaded">): boolean;

export declare function validateMultipartKey(method: string, key: string): void;

/* Excluded from this release type: _valueToArray */

export { }
